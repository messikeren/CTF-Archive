;
; +-------------------------------------------------------------------------+
; |      This file was generated by The Interactive Disassembler (IDA)      |
; |           Copyright (c) 2025 Hex-Rays, <support@hex-rays.com>           |
; |                            Freeware version                             |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : CB5FF191E6D2C2F95561100E10AA7FA7031FB9AB4F01C8B23F5EEC96C5CA51E7
; Input MD5    : BF295AE5BC6CC59DEAEE12C5F6765620
; Input CRC32  : F73ED8E3
; Compiler     : GNU C++

; File Name   : D:\CTF #2\STEMBACTF\REVERSE\one by one\chall
; Format      : ELF64 for x86-64 (Shared object)
; Interpreter '/lib64/ld-linux-x86-64.so.2'
; Needed Library 'libc.so.6'
;
; Source File : 'Scrt1.o'
; Source File : 'crtstuff.c'
; Source File : 'chall.c'
; Source File : 'crtstuff.c'

.686p
.mmx
.model flat
.intel_syntax noprefix


; Segment type: Pure data
; Segment permissions: Read
LOAD segment mempage public 'DATA' use64
assume cs:LOAD
dword_0 dd 464C457Fh    ; File format: \x7FELF
db 2                    ; File class: 64-bit
db 1                    ; Data encoding: little-endian
db 1                    ; File version
db 0                    ; OS/ABI: UNIX System V ABI
db 0                    ; ABI Version
db 7 dup(0)             ; Padding
dw 3                    ; File type: Shared object
dw 3Eh                  ; Machine: x86-64
dd 1                    ; File version
dq offset _start        ; Entry point
dq 40h                  ; PHT file offset
dq 3918h                ; SHT file offset
dd 0                    ; Processor-specific flags
dw 40h                  ; ELF header size
dw 38h                  ; PHT entry size
dw 0Dh                  ; Number of entries in PHT
dw 40h                  ; SHT entry size
dw 1Fh                  ; Number of entries in SHT
dw 1Eh                  ; SHT entry index for string table
; ELF64 Program Header
; PHT Entry 0
dword_40 dd 6           ; Type: PHDR
dd 4                    ; Flags
dq 40h                  ; File offset
dq offset dword_40      ; Virtual address
dq 40h                  ; Physical address
dq 2D8h                 ; Size in file image
dq 2D8h                 ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 1
dd 3                    ; Type: INTERP
dd 4                    ; Flags
dq 318h                 ; File offset
dq offset aLib64LdLinuxX8 ; Virtual address
dq 318h                 ; Physical address
dq 1Ch                  ; Size in file image
dq 1Ch                  ; Size in memory image
dq 1                    ; Alignment
; PHT Entry 2
dd 1                    ; Type: LOAD
dd 4                    ; Flags
dq 0                    ; File offset
dq 0                    ; Virtual address
dq 0                    ; Physical address
dq 8D0h                 ; Size in file image
dq 8D0h                 ; Size in memory image
dq 1000h                ; Alignment
; PHT Entry 3
dd 1                    ; Type: LOAD
dd 5                    ; Flags
dq 1000h                ; File offset
dq offset _init_proc    ; Virtual address
dq 1000h                ; Physical address
dq 415h                 ; Size in file image
dq 415h                 ; Size in memory image
dq 1000h                ; Alignment
; PHT Entry 4
dd 1                    ; Type: LOAD
dd 4                    ; Flags
dq 2000h                ; File offset
dq offset _IO_stdin_used ; Virtual address
dq 2000h                ; Physical address
dq 178h                 ; Size in file image
dq 178h                 ; Size in memory image
dq 1000h                ; Alignment
; PHT Entry 5
dd 1                    ; Type: LOAD
dd 6                    ; Flags
dq 2DD0h                ; File offset
dq offset __frame_dummy_init_array_entry ; Virtual address
dq 3DD0h                ; Physical address
dq 290h                 ; Size in file image
dq 2C0h                 ; Size in memory image
dq 1000h                ; Alignment
; PHT Entry 6
dd 2                    ; Type: DYNAMIC
dd 6                    ; Flags
dq 2DE0h                ; File offset
dq offset _DYNAMIC      ; Virtual address
dq 3DE0h                ; Physical address
dq 1E0h                 ; Size in file image
dq 1E0h                 ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 7
dd 4                    ; Type: NOTE
dd 4                    ; Flags
dq 338h                 ; File offset
dq offset dword_338     ; Virtual address
dq 338h                 ; Physical address
dq 20h                  ; Size in file image
dq 20h                  ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 8
dd 4                    ; Type: NOTE
dd 4                    ; Flags
dq 358h                 ; File offset
dq offset dword_358     ; Virtual address
dq 358h                 ; Physical address
dq 44h                  ; Size in file image
dq 44h                  ; Size in memory image
dq 4                    ; Alignment
; PHT Entry 9
dd 6474E553h            ; Type: 6474E553
dd 4                    ; Flags
dq 338h                 ; File offset
dq offset dword_338     ; Virtual address
dq 338h                 ; Physical address
dq 20h                  ; Size in file image
dq 20h                  ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 10
dd 6474E550h            ; Type: EH_FRAME
dd 4                    ; Flags
dq 2048h                ; File offset
dq offset __GNU_EH_FRAME_HDR ; Virtual address
dq 2048h                ; Physical address
dq 3Ch                  ; Size in file image
dq 3Ch                  ; Size in memory image
dq 4                    ; Alignment
; PHT Entry 11
dd 6474E551h            ; Type: STACK
dd 6                    ; Flags
dq 0                    ; File offset
dq 0                    ; Virtual address
dq 0                    ; Physical address
dq 0                    ; Size in file image
dq 0                    ; Size in memory image
dq 10h                  ; Alignment
; PHT Entry 12
dd 6474E552h            ; Type: RO-AFTER
dd 4                    ; Flags
dq 2DD0h                ; File offset
dq offset __frame_dummy_init_array_entry ; Virtual address
dq 3DD0h                ; Physical address
dq 230h                 ; Size in file image
dq 230h                 ; Size in memory image
dq 1                    ; Alignment
aLib64LdLinuxX8 db '/lib64/ld-linux-x86-64.so.2',0
align 8
; ELF Note Entry
dword_338 dd 4          ; Name Size
dd 10h                  ; Desc Size
dd 5                    ; Type: NT_GNU_PROPERTY_TYPE_0
aGnu db 'GNU',0         ; Name
db 2, 80h, 0, 0C0h, 4, 3 dup(0), 1, 7 dup(0) ; Desc
; ELF Note Entry
dword_358 dd 4          ; Name Size
dd 14h                  ; Desc Size
dd 3                    ; Type: NT_GNU_BUILD_ID
aGnu_0 db 'GNU',0       ; Name
db 2Ch, 53h, 0A5h, 41h, 5Eh, 0C4h, 0F6h ; Desc
db 64h, 8Fh, 7, 3Ah, 39h, 0Bh, 0E8h, 0Dh
db 0E5h, 73h, 0EDh, 0E6h, 0A6h
; ELF Note Entry
__abi_tag dd 4          ; Name Size
dd 10h                  ; Desc Size
dd 1                    ; Type: NT_GNU_ABI_TAG
aGnu_1 db 'GNU',0       ; Name
dd 0, 3, 2, 0           ; ABI: Linux 3.2.0
align 20h
; ELF GNU Hash Table
elf_gnu_hash_nbuckets dd 3
elf_gnu_hash_symbias dd 0Fh
elf_gnu_hash_bitmask_nwords dd 1
elf_gnu_hash_shift dd 6
elf_gnu_hash_indexes dq 210018000A10100h
elf_gnu_hash_bucket dd 0Fh, 11h, 0
elf_gnu_hash_chain dd 1C8C1D28h, 6DCE65D1h, 10615566h, 1C8BF239h
dd 0
; ELF Symbol Table
Elf64_Sym <0>
Elf64_Sym <offset aLibcStartMain - offset unk_5A0,\ ; "__libc_start_main"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aItmDeregistert - offset unk_5A0,\ ; "_ITM_deregisterTMCloneTable"
           20h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aPuts - offset unk_5A0,\ ; "puts"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aFclose - offset unk_5A0,\ ; "fclose"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aStrlen - offset unk_5A0,\ ; "strlen"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aPrintf - offset unk_5A0,\ ; "printf"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aFgets - offset unk_5A0,\ ; "fgets"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aGmonStart - offset unk_5A0,\ ; "__gmon_start__"
           20h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aMalloc - offset unk_5A0,\ ; "malloc"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aSetvbuf - offset unk_5A0,\ ; "setvbuf"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aFopen - offset unk_5A0,\ ; "fopen"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aStrcat - offset unk_5A0,\ ; "strcat"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aExit - offset unk_5A0,\ ; "exit"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aItmRegistertmc - offset unk_5A0,\ ; "_ITM_registerTMCloneTable"
           20h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aStdout - offset unk_5A0,\ ; "stdout"
           11h, 0, 1Ah, \
           offset stdout@GLIBC_2_2_5, 8>
Elf64_Sym <offset aCxaFinalize - offset unk_5A0,\ ; "__cxa_finalize"
           22h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aStdin - offset unk_5A0,\ ; "stdin"
           11h, 0, 1Ah, \
           offset stdin@GLIBC_2_2_5, 8>
Elf64_Sym <offset aStderr - offset unk_5A0,\ ; "stderr"
           11h, 0, 1Ah, \
           offset stderr@GLIBC_2_2_5, 8>
; ELF String Table
unk_5A0 db    0
aFgets db 'fgets',0
aSetvbuf db 'setvbuf',0
aStdin db 'stdin',0
aPuts db 'puts',0
aExit db 'exit',0
aFopen db 'fopen',0
aStrlen db 'strlen',0
aStdout db 'stdout',0
aStrcat db 'strcat',0
aMalloc db 'malloc',0
aLibcStartMain db '__libc_start_main',0
aStderr db 'stderr',0
aCxaFinalize db '__cxa_finalize',0
aFclose db 'fclose',0
aPrintf db 'printf',0
aLibcSo6 db 'libc.so.6',0
aGlibc225 db 'GLIBC_2.2.5',0
aGlibc234 db 'GLIBC_2.34',0
aItmDeregistert db '_ITM_deregisterTMCloneTable',0
aGmonStart db '__gmon_start__',0
aItmRegistertmc db '_ITM_registerTMCloneTable',0
align 2
; ELF GNU Symbol Version Table
dw 0
dw 2                    ; __libc_start_main@@GLIBC_2.34
dw 1                    ; global symbol: _ITM_deregisterTMCloneTable
dw 3                    ; puts@@GLIBC_2.2.5
dw 3                    ; fclose@@GLIBC_2.2.5
dw 3                    ; strlen@@GLIBC_2.2.5
dw 3                    ; printf@@GLIBC_2.2.5
dw 3                    ; fgets@@GLIBC_2.2.5
dw 1                    ; global symbol: __gmon_start__
dw 3                    ; malloc@@GLIBC_2.2.5
dw 3                    ; setvbuf@@GLIBC_2.2.5
dw 3                    ; fopen@@GLIBC_2.2.5
dw 3                    ; strcat@@GLIBC_2.2.5
dw 3                    ; exit@@GLIBC_2.2.5
dw 1                    ; global symbol: _ITM_registerTMCloneTable
dw 3                    ; stdout@@GLIBC_2.2.5
dw 3                    ; __cxa_finalize@@GLIBC_2.2.5
dw 3                    ; stdin@@GLIBC_2.2.5
dw 3                    ; stderr@@GLIBC_2.2.5
dw 0
dw 0
; ELF GNU Symbol Version Requirements
Elf64_Verneed <1, 2, \  ; "libc.so.6"
               offset aLibcSo6 - offset unk_5A0,\
               10h, 0>
Elf64_Vernaux <9691A75h, 0, 3, \ ; "GLIBC_2.2.5"
               offset aGlibc225 - offset unk_5A0,\
               10h>
Elf64_Vernaux <69691B4h, 0, 2, \ ; "GLIBC_2.34"
               offset aGlibc234 - offset unk_5A0,\
               0>
; ELF RELA Relocation Table
Elf64_Rela <3DD0h, 8, 11C0h> ; R_X86_64_RELATIVE +11C0h
Elf64_Rela <3DD8h, 8, 1180h> ; R_X86_64_RELATIVE +1180h
Elf64_Rela <4058h, 8, 4058h> ; R_X86_64_RELATIVE +4058h
Elf64_Rela <3FC0h, 100000006h, 0> ; R_X86_64_GLOB_DAT __libc_start_main
Elf64_Rela <3FC8h, 200000006h, 0> ; R_X86_64_GLOB_DAT _ITM_deregisterTMCloneTable
Elf64_Rela <3FD0h, 800000006h, 0> ; R_X86_64_GLOB_DAT __gmon_start__
Elf64_Rela <3FD8h, 0E00000006h, 0> ; R_X86_64_GLOB_DAT _ITM_registerTMCloneTable
Elf64_Rela <3FE0h, 1000000006h, 0> ; R_X86_64_GLOB_DAT __cxa_finalize
Elf64_Rela <4060h, 0F00000005h, 0> ; R_X86_64_COPY stdout
Elf64_Rela <4070h, 1100000005h, 0> ; R_X86_64_COPY stdin
Elf64_Rela <4080h, 1200000005h, 0> ; R_X86_64_COPY stderr
; ELF JMPREL Relocation Table
Elf64_Rela <4000h, 300000007h, 0> ; R_X86_64_JUMP_SLOT puts
Elf64_Rela <4008h, 400000007h, 0> ; R_X86_64_JUMP_SLOT fclose
Elf64_Rela <4010h, 500000007h, 0> ; R_X86_64_JUMP_SLOT strlen
Elf64_Rela <4018h, 600000007h, 0> ; R_X86_64_JUMP_SLOT printf
Elf64_Rela <4020h, 700000007h, 0> ; R_X86_64_JUMP_SLOT fgets
Elf64_Rela <4028h, 900000007h, 0> ; R_X86_64_JUMP_SLOT malloc
Elf64_Rela <4030h, 0A00000007h, 0> ; R_X86_64_JUMP_SLOT setvbuf
Elf64_Rela <4038h, 0B00000007h, 0> ; R_X86_64_JUMP_SLOT fopen
Elf64_Rela <4040h, 0C00000007h, 0> ; R_X86_64_JUMP_SLOT strcat
Elf64_Rela <4048h, 0D00000007h, 0> ; R_X86_64_JUMP_SLOT exit
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_init segment dword public 'CODE' use64
assume cs:_init
;org 1000h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing


; Alternative name is '_init'

public _init_proc
_init_proc proc near
sub     rsp, 8
mov     rax, cs:__gmon_start___ptr
test    rax, rax
jz      short loc_1012
call    rax ; __gmon_start__

loc_1012:
add     rsp, 8
retn
_init_proc endp

_init ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment mempage public 'CODE' use64
assume cs:LOAD
;org 1017h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 20h
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_plt segment para public 'CODE' use64
assume cs:_plt
;org 1020h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



sub_1020 proc near
; __unwind {
push    cs:qword_3FF0
jmp     cs:qword_3FF8
sub_1020 endp

align 10h
; [00000006 BYTES: COLLAPSED FUNCTION _puts. PRESS CTRL-NUMPAD+ TO EXPAND]
push    0
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _fclose. PRESS CTRL-NUMPAD+ TO EXPAND]
push    1
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _strlen. PRESS CTRL-NUMPAD+ TO EXPAND]
push    2
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _printf. PRESS CTRL-NUMPAD+ TO EXPAND]
push    3
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _fgets. PRESS CTRL-NUMPAD+ TO EXPAND]
push    4
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _malloc. PRESS CTRL-NUMPAD+ TO EXPAND]
push    5
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _setvbuf. PRESS CTRL-NUMPAD+ TO EXPAND]
push    6
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _fopen. PRESS CTRL-NUMPAD+ TO EXPAND]
push    7
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _strcat. PRESS CTRL-NUMPAD+ TO EXPAND]
push    8
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _exit. PRESS CTRL-NUMPAD+ TO EXPAND]
push    9
jmp     sub_1020
; } // starts at 1020
_plt ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_plt_got segment qword public 'CODE' use64
assume cs:_plt_got
;org 10D0h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; [00000006 BYTES: COLLAPSED FUNCTION __cxa_finalize. PRESS CTRL-NUMPAD+ TO EXPAND]
align 8
; } // starts at 10D0
_plt_got ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment mempage public 'CODE' use64
assume cs:LOAD
;org 10D8h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 20h
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_text segment para public 'CODE' use64
assume cs:_text
;org 10E0h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing


; Attributes: noreturn fuzzy-sp

public _start
_start proc near
; __unwind {
xor     ebp, ebp
mov     r9, rdx         ; rtld_fini
pop     rsi             ; argc
mov     rdx, rsp        ; ubp_av
and     rsp, 0FFFFFFFFFFFFFFF0h
push    rax
push    rsp             ; stack_end
xor     r8d, r8d        ; fini
xor     ecx, ecx        ; init
lea     rdi, main       ; main
call    cs:__libc_start_main_ptr
hlt
; } // starts at 10E0
_start endp

align 10h



deregister_tm_clones proc near
lea     rdi, stdout@GLIBC_2_2_5
lea     rax, stdout@GLIBC_2_2_5
cmp     rax, rdi
jz      short locret_1138
mov     rax, cs:_ITM_deregisterTMCloneTable_ptr
test    rax, rax
jz      short locret_1138
jmp     rax
align 8

locret_1138:
retn
deregister_tm_clones endp

align 20h



register_tm_clones proc near
lea     rdi, stdout@GLIBC_2_2_5
lea     rsi, stdout@GLIBC_2_2_5
sub     rsi, rdi
mov     rax, rsi
shr     rsi, 3Fh
sar     rax, 3
add     rsi, rax
sar     rsi, 1
jz      short locret_1178
mov     rax, cs:_ITM_registerTMCloneTable_ptr
test    rax, rax
jz      short locret_1178
jmp     rax
align 8

locret_1178:
retn
register_tm_clones endp

align 20h



__do_global_dtors_aux proc near
endbr64
cmp     cs:completed_0, 0
jnz     short locret_11B8
push    rbp
cmp     cs:__cxa_finalize_ptr, 0
mov     rbp, rsp
jz      short loc_11A7
mov     rdi, cs:__dso_handle ; void *
call    __cxa_finalize

loc_11A7:
call    deregister_tm_clones
mov     cs:completed_0, 1
pop     rbp
retn
align 8

locret_11B8:
retn
__do_global_dtors_aux endp

align 20h



frame_dummy proc near
endbr64
jmp     register_tm_clones
frame_dummy endp



; Attributes: bp-based frame

public readFile
readFile proc near

s= byte ptr -50h
dest= qword ptr -10h
stream= qword ptr -8

; __unwind {
push    rbp
mov     rbp, rsp
sub     rsp, 50h
lea     rax, modes      ; "r"
mov     rsi, rax        ; modes
lea     rax, filename   ; "flag.txt"
mov     rdi, rax        ; filename
call    _fopen
mov     [rbp+stream], rax
cmp     [rbp+stream], 0
jnz     short loc_1204
lea     rax, s          ; "file can't be opened "
mov     rdi, rax        ; s
call    _puts

loc_1204:               ; stream
mov     rdx, [rbp+stream]
lea     rax, [rbp+s]
mov     esi, 32h ; '2'  ; n
mov     rdi, rax        ; s
call    _fgets
mov     edi, 32h ; '2'  ; size
call    _malloc
mov     [rbp+dest], rax
lea     rdx, [rbp+s]
mov     rax, [rbp+dest]
mov     rsi, rdx        ; src
mov     rdi, rax        ; dest
call    _strcat
mov     rax, [rbp+stream]
mov     rdi, rax        ; stream
call    _fclose
mov     rax, [rbp+dest]
leave
retn
; } // starts at 11C9
readFile endp



; Attributes: bp-based frame

public setup
setup proc near
; __unwind {
push    rbp
mov     rbp, rsp
mov     rax, cs:stdin@GLIBC_2_2_5
mov     ecx, 0          ; n
mov     edx, 2          ; modes
mov     esi, 0          ; buf
mov     rdi, rax        ; stream
call    _setvbuf
mov     rax, cs:stdout@GLIBC_2_2_5
mov     ecx, 0          ; n
mov     edx, 2          ; modes
mov     esi, 0          ; buf
mov     rdi, rax        ; stream
call    _setvbuf
mov     rax, cs:stderr@GLIBC_2_2_5
mov     ecx, 0          ; n
mov     edx, 2          ; modes
mov     esi, 0          ; buf
mov     rdi, rax        ; stream
call    _setvbuf
nop
pop     rbp
retn
; } // starts at 124C
setup endp



; Attributes: bp-based frame

; int __fastcall main(int argc, const char **argv, const char **envp)
public main
main proc near

s= byte ptr -60h
var_20= qword ptr -20h
var_14= dword ptr -14h
var_8= qword ptr -8

; __unwind {
push    rbp
mov     rbp, rsp
push    rbx
sub     rsp, 58h
mov     eax, 0
call    setup
mov     eax, 0
call    readFile
mov     [rbp+var_20], rax
mov     rdx, cs:stdin@GLIBC_2_2_5 ; stream
lea     rax, [rbp+s]
mov     esi, 32h ; '2'  ; n
mov     rdi, rax        ; s
call    _fgets
lea     rax, [rbp+s]
mov     rdi, rax        ; s
call    _strlen
cmp     rax, 1
ja      short loc_1322
mov     rax, [rbp+var_20]
movzx   eax, byte ptr [rax]
movsx   eax, al
mov     esi, eax
lea     rax, format     ; "%x"
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
mov     edi, 1          ; status
call    _exit

loc_1322:
mov     [rbp+var_14], 0
jmp     short loc_1380

loc_132B:
mov     eax, [rbp+var_14]
cdqe
movzx   edx, [rbp+rax+s]
mov     eax, [rbp+var_14]
movsxd  rcx, eax
mov     rax, [rbp+var_20]
add     rax, rcx
movzx   eax, byte ptr [rax]
cmp     dl, al
jz      short loc_137C
mov     eax, [rbp+var_14]
movsxd  rdx, eax
mov     rax, [rbp+var_20]
add     rax, rdx
movzx   eax, byte ptr [rax]
movsx   eax, al
mov     esi, eax
lea     rax, format     ; "%x"
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
mov     eax, 0
jmp     loc_1406

loc_137C:
add     [rbp+var_14], 1

loc_1380:
mov     eax, [rbp+var_14]
movsxd  rbx, eax
lea     rax, [rbp+s]
mov     rdi, rax        ; s
call    _strlen
cmp     rbx, rax
jb      short loc_132B
lea     rax, [rbp+s]
mov     rdi, rax        ; s
call    _strlen
mov     rbx, rax
mov     rax, [rbp+var_20]
mov     rdi, rax        ; s
call    _strlen
cmp     rbx, rax
jz      short loc_13ED
lea     rax, [rbp+s]
mov     rdi, rax        ; s
call    _strlen
mov     rdx, [rbp+var_20]
add     rax, rdx
movzx   eax, byte ptr [rax]
movsx   eax, al
mov     esi, eax
lea     rax, format     ; "%x"
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
mov     eax, 0
jmp     short loc_1406

loc_13ED:
lea     rax, aCongratsFlagny ; "Congrats, flagnya sudah benar"
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
mov     eax, 0

loc_1406:
mov     rbx, [rbp+var_8]
leave
retn
; } // starts at 12AD
main endp

_text ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_fini segment dword public 'CODE' use64
assume cs:_fini
;org 140Ch
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing


; Alternative name is '_fini'

public _term_proc
_term_proc proc near
sub     rsp, 8
add     rsp, 8
retn
_term_proc endp

_fini ends


; Segment type: Pure data
; Segment permissions: Read
_rodata segment dword public 'CONST' use64
assume cs:_rodata
;org 2000h
public _IO_stdin_used
_IO_stdin_used db    1
db    0
db    2
db    0
; const char modes[2]
modes db 'r',0
; const char filename[]
filename db 'flag.txt',0
; const char s[]
s db 'file can',27h,'t be opened ',0
; const char format[]
format db '%x',0
; const char aCongratsFlagny[]
aCongratsFlagny db 'Congrats, flagnya sudah benar',0
_rodata ends


; Segment type: Pure data
; Segment permissions: Read
LOAD segment mempage public 'DATA' use64
assume cs:LOAD
;org 2046h
align 8
LOAD ends


; Segment type: Pure data
; Segment permissions: Read
_eh_frame_hdr segment dword public 'CONST' use64
assume cs:_eh_frame_hdr
;org 2048h
__GNU_EH_FRAME_HDR db    1
db  1Bh
db    3
db  3Bh ; ;
db  3Ch ; <
db    0
db    0
db    0
db    6
db    0
db    0
db    0
db 0D8h
db 0EFh
db 0FFh
db 0FFh
db  88h
db    0
db    0
db    0
db  88h
db 0F0h
db 0FFh
db 0FFh
db 0B0h
db    0
db    0
db    0
db  98h
db 0F0h
db 0FFh
db 0FFh
db  58h ; X
db    0
db    0
db    0
db  81h
db 0F1h
db 0FFh
db 0FFh
db 0C8h
db    0
db    0
db    0
db    4
db 0F2h
db 0FFh
db 0FFh
db 0E8h
db    0
db    0
db    0
db  65h ; e
db 0F2h
db 0FFh
db 0FFh
db    8
db    1
db    0
db    0
_eh_frame_hdr ends


; Segment type: Pure data
; Segment permissions: Read
LOAD segment mempage public 'DATA' use64
assume cs:LOAD
;org 2084h
align 8
LOAD ends


; Segment type: Pure data
; Segment permissions: Read
_eh_frame segment qword public 'CONST' use64
assume cs:_eh_frame
;org 2088h
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah ; z
db  52h ; R
db    0
db    1
db  78h ; x
db  10h
db    1
db  1Bh
db  0Ch
db    7
db    8
db  90h
db    1
db    7
db  10h
db  14h
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  38h ; 8
db 0F0h
db 0FFh
db 0FFh
db  22h ; "
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah ; z
db  52h ; R
db    0
db    1
db  78h ; x
db  10h
db    1
db  1Bh
db  0Ch
db    7
db    8
db  90h
db    1
db    0
db    0
db  24h ; $
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  48h ; H
db 0EFh
db 0FFh
db 0FFh
db 0B0h
db    0
db    0
db    0
db    0
db  0Eh
db  10h
db  46h ; F
db  0Eh
db  18h
db  4Ah ; J
db  0Fh
db  0Bh
db  77h ; w
db    8
db  80h
db    0
db  3Fh ; ?
db  1Ah
db  3Bh ; ;
db  2Ah ; *
db  33h ; 3
db  24h ; $
db  22h ; "
db    0
db    0
db    0
db    0
db  14h
db    0
db    0
db    0
db  44h ; D
db    0
db    0
db    0
db 0D0h
db 0EFh
db 0FFh
db 0FFh
db    8
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  5Ch ; \
db    0
db    0
db    0
db 0B1h
db 0F0h
db 0FFh
db 0FFh
db  83h
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    2
db  7Eh ; ~
db  0Ch
db    7
db    8
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  7Ch ; |
db    0
db    0
db    0
db  14h
db 0F1h
db 0FFh
db 0FFh
db  61h ; a
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    2
db  5Ch ; \
db  0Ch
db    7
db    8
db    0
db    0
db  20h
db    0
db    0
db    0
db  9Ch
db    0
db    0
db    0
db  55h ; U
db 0F1h
db 0FFh
db 0FFh
db  5Fh ; _
db    1
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db  45h ; E
db  83h
db    3
db    3
db  55h ; U
db    1
db  0Ch
db    7
db    8
db    0
db    0
__FRAME_END__ db    0
db    0
db    0
db    0
_eh_frame ends

; ELF Initialization Function Table

; Segment type: Pure data
; Segment permissions: Read/Write
_init_array segment qword public 'DATA' use64
assume cs:_init_array
;org 3DD0h
__frame_dummy_init_array_entry dq offset frame_dummy
_init_array ends

; ELF Termination Function Table

; Segment type: Pure data
; Segment permissions: Read/Write
_fini_array segment qword public 'DATA' use64
assume cs:_fini_array
;org 3DD8h
__do_global_dtors_aux_fini_array_entry dq offset __do_global_dtors_aux
_fini_array ends

; ELF Dynamic Information

; Segment type: Pure data
; Segment permissions: Read/Write
LOAD segment mempage public 'DATA' use64
assume cs:LOAD
;org 3DE0h
_DYNAMIC Elf64_Dyn <1, 77h> ; DT_NEEDED libc.so.6
Elf64_Dyn <0Ch, 1000h>  ; DT_INIT
Elf64_Dyn <0Dh, 140Ch>  ; DT_FINI
Elf64_Dyn <19h, 3DD0h>  ; DT_INIT_ARRAY
Elf64_Dyn <1Bh, 8>      ; DT_INIT_ARRAYSZ
Elf64_Dyn <1Ah, 3DD8h>  ; DT_FINI_ARRAY
Elf64_Dyn <1Ch, 8>      ; DT_FINI_ARRAYSZ
Elf64_Dyn <6FFFFEF5h, 3A0h> ; DT_GNU_HASH
Elf64_Dyn <5, 5A0h>     ; DT_STRTAB
Elf64_Dyn <6, 3D8h>     ; DT_SYMTAB
Elf64_Dyn <0Ah, 0DDh>   ; DT_STRSZ
Elf64_Dyn <0Bh, 18h>    ; DT_SYMENT
Elf64_Dyn <15h, 0>      ; DT_DEBUG
Elf64_Dyn <3, 3FE8h>    ; DT_PLTGOT
Elf64_Dyn <2, 0F0h>     ; DT_PLTRELSZ
Elf64_Dyn <14h, 7>      ; DT_PLTREL
Elf64_Dyn <17h, 7E0h>   ; DT_JMPREL
Elf64_Dyn <7, 6D8h>     ; DT_RELA
Elf64_Dyn <8, 108h>     ; DT_RELASZ
Elf64_Dyn <9, 18h>      ; DT_RELAENT
Elf64_Dyn <6FFFFFFBh, 8000000h> ; DT_FLAGS_1
Elf64_Dyn <6FFFFFFEh, 6A8h> ; DT_VERNEED
Elf64_Dyn <6FFFFFFFh, 1> ; DT_VERNEEDNUM
Elf64_Dyn <6FFFFFF0h, 67Eh> ; DT_VERSYM
Elf64_Dyn <6FFFFFF9h, 3> ; DT_RELACOUNT
Elf64_Dyn <0>           ; DT_NULL
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
LOAD ends


; Segment type: Pure data
; Segment permissions: Read/Write
_got segment qword public 'DATA' use64
assume cs:_got
;org 3FC0h
__libc_start_main_ptr dq offset __libc_start_main
_ITM_deregisterTMCloneTable_ptr dq offset _ITM_deregisterTMCloneTable
__gmon_start___ptr dq offset __gmon_start__
_ITM_registerTMCloneTable_ptr dq offset _ITM_registerTMCloneTable
__cxa_finalize_ptr dq offset __imp___cxa_finalize
_got ends


; Segment type: Pure data
; Segment permissions: Read/Write
_got_plt segment qword public 'DATA' use64
assume cs:_got_plt
;org 3FE8h
_GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC
qword_3FF0 dq 0
qword_3FF8 dq 0
off_4000 dq offset puts
off_4008 dq offset fclose
off_4010 dq offset strlen
off_4018 dq offset printf
off_4020 dq offset fgets
off_4028 dq offset malloc
off_4030 dq offset setvbuf
off_4038 dq offset fopen
off_4040 dq offset strcat
off_4048 dq offset exit
_got_plt ends


; Segment type: Pure data
; Segment permissions: Read/Write
_data segment qword public 'DATA' use64
assume cs:_data
;org 4050h
public __data_start
__data_start db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
public __dso_handle
; void *_dso_handle
__dso_handle dq offset __dso_handle
_data ends


; Segment type: Uninitialized
; Segment permissions: Read/Write
_bss segment align_32 public 'BSS' use64
assume cs:_bss
;org 4060h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
public stdout@GLIBC_2_2_5
; FILE *stdout
stdout@GLIBC_2_2_5 dq ? ; Alternative name is '__TMC_END__'
                        ; Alternative name is 'stdout'
                        ; Alternative name is '_edata'
                        ; Alternative name is '__bss_start'
                        ; Copy of shared data
align 10h
public stdin@GLIBC_2_2_5
; FILE *stdin
stdin@GLIBC_2_2_5 dq ?  ; Alternative name is 'stdin'
                        ; Copy of shared data
align 20h
public stderr@GLIBC_2_2_5
; FILE *stderr
stderr@GLIBC_2_2_5 dq ? ; Alternative name is 'stderr'
                        ; Copy of shared data
completed_0 db ?
align 10h
_bss ends


; Segment type: Zero-length
_prgend segment byte public '' use64
_end label byte
_prgend ends


; Segment type: Externs
; extern
; int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end)
extrn __libc_start_main:near
; int puts(const char *s)
extrn puts:near
; int fclose(FILE *stream)
extrn fclose:near
; size_t strlen(const char *s)
extrn strlen:near
; int printf(const char *format, ...)
extrn printf:near
; char *fgets(char *s, int n, FILE *stream)
extrn fgets:near
; void *malloc(size_t size)
extrn malloc:near
; int setvbuf(FILE *stream, char *buf, int modes, size_t n)
extrn setvbuf:near
; FILE *fopen(const char *filename, const char *modes)
extrn fopen:near
; char *strcat(char *dest, const char *src)
extrn strcat:near
; void __noreturn exit(int status)
extrn exit:near
; int __cxa_finalize(void *)
extrn __imp___cxa_finalize:near ; weak
extrn _ITM_deregisterTMCloneTable ; weak
extrn __gmon_start__:near ; weak
extrn _ITM_registerTMCloneTable ; weak


end _start
