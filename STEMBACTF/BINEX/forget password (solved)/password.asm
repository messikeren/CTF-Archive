;
; +-------------------------------------------------------------------------+
; |      This file was generated by The Interactive Disassembler (IDA)      |
; |           Copyright (c) 2025 Hex-Rays, <support@hex-rays.com>           |
; |                            Freeware version                             |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : 32C79A35CAAF8F58A1327BDF6E210FCCB960E1F1ECBB70ED9B4DBD98409C333E
; Input MD5    : 0807155E82C6A519CE66E9F2864609A6
; Input CRC32  : 607FE9E4
; Compiler     : GNU C++

; File Name   : D:\CTF #2\STEMBACTF\BINEX\forget password\password
; Format      : ELF64 for x86-64 (Shared object)
; Interpreter '/lib64/ld-linux-x86-64.so.2'
; Needed Library 'libc.so.6'
;
; Source File : 'Scrt1.o'
; Source File : 'crtstuff.c'
; Source File : 'password.c'
; Source File : 'crtstuff.c'

.686p
.mmx
.model flat
.intel_syntax noprefix


; Segment type: Pure data
; Segment permissions: Read
LOAD segment mempage public 'DATA' use64
assume cs:LOAD
dword_0 dd 464C457Fh    ; File format: \x7FELF
db 2                    ; File class: 64-bit
db 1                    ; Data encoding: little-endian
db 1                    ; File version
db 0                    ; OS/ABI: UNIX System V ABI
db 0                    ; ABI Version
db 7 dup(0)             ; Padding
dw 3                    ; File type: Shared object
dw 3Eh                  ; Machine: x86-64
dd 1                    ; File version
dq offset _start        ; Entry point
dq 40h                  ; PHT file offset
dq 3940h                ; SHT file offset
dd 0                    ; Processor-specific flags
dw 40h                  ; ELF header size
dw 38h                  ; PHT entry size
dw 0Eh                  ; Number of entries in PHT
dw 40h                  ; SHT entry size
dw 1Fh                  ; Number of entries in SHT
dw 1Eh                  ; SHT entry index for string table
; ELF64 Program Header
; PHT Entry 0
dword_40 dd 6           ; Type: PHDR
dd 4                    ; Flags
dq 40h                  ; File offset
dq offset dword_40      ; Virtual address
dq 40h                  ; Physical address
dq 310h                 ; Size in file image
dq 310h                 ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 1
dd 3                    ; Type: INTERP
dd 4                    ; Flags
dq 394h                 ; File offset
dq offset aLib64LdLinuxX8 ; Virtual address
dq 394h                 ; Physical address
dq 1Ch                  ; Size in file image
dq 1Ch                  ; Size in memory image
dq 1                    ; Alignment
; PHT Entry 2
dd 1                    ; Type: LOAD
dd 4                    ; Flags
dq 0                    ; File offset
dq 0                    ; Virtual address
dq 0                    ; Physical address
dq 8E8h                 ; Size in file image
dq 8E8h                 ; Size in memory image
dq 1000h                ; Alignment
; PHT Entry 3
dd 1                    ; Type: LOAD
dd 5                    ; Flags
dq 1000h                ; File offset
dq offset _init_proc    ; Virtual address
dq 1000h                ; Physical address
dq 541h                 ; Size in file image
dq 541h                 ; Size in memory image
dq 1000h                ; Alignment
; PHT Entry 4
dd 1                    ; Type: LOAD
dd 4                    ; Flags
dq 2000h                ; File offset
dq offset _IO_stdin_used ; Virtual address
dq 2000h                ; Physical address
dq 2A0h                 ; Size in file image
dq 2A0h                 ; Size in memory image
dq 1000h                ; Alignment
; PHT Entry 5
dd 1                    ; Type: LOAD
dd 6                    ; Flags
dq 2DD0h                ; File offset
dq offset __frame_dummy_init_array_entry ; Virtual address
dq 3DD0h                ; Physical address
dq 2A0h                 ; Size in file image
dq 2B0h                 ; Size in memory image
dq 1000h                ; Alignment
; PHT Entry 6
dd 2                    ; Type: DYNAMIC
dd 6                    ; Flags
dq 2DE0h                ; File offset
dq offset _DYNAMIC      ; Virtual address
dq 3DE0h                ; Physical address
dq 1E0h                 ; Size in file image
dq 1E0h                 ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 7
dd 4                    ; Type: NOTE
dd 4                    ; Flags
dq 350h                 ; File offset
dq offset dword_350     ; Virtual address
dq 350h                 ; Physical address
dq 20h                  ; Size in file image
dq 20h                  ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 8
dd 4                    ; Type: NOTE
dd 4                    ; Flags
dq 370h                 ; File offset
dq offset dword_370     ; Virtual address
dq 370h                 ; Physical address
dq 24h                  ; Size in file image
dq 24h                  ; Size in memory image
dq 4                    ; Alignment
; PHT Entry 9
dd 4                    ; Type: NOTE
dd 4                    ; Flags
dq 2280h                ; File offset
dq offset __abi_tag     ; Virtual address
dq 2280h                ; Physical address
dq 20h                  ; Size in file image
dq 20h                  ; Size in memory image
dq 4                    ; Alignment
; PHT Entry 10
dd 6474E553h            ; Type: 6474E553
dd 4                    ; Flags
dq 350h                 ; File offset
dq offset dword_350     ; Virtual address
dq 350h                 ; Physical address
dq 20h                  ; Size in file image
dq 20h                  ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 11
dd 6474E550h            ; Type: EH_FRAME
dd 4                    ; Flags
dq 213Ch                ; File offset
dq offset __GNU_EH_FRAME_HDR ; Virtual address
dq 213Ch                ; Physical address
dq 44h                  ; Size in file image
dq 44h                  ; Size in memory image
dq 4                    ; Alignment
; PHT Entry 12
dd 6474E551h            ; Type: STACK
dd 7                    ; Flags
dq 0                    ; File offset
dq 0                    ; Virtual address
dq 0                    ; Physical address
dq 0                    ; Size in file image
dq 0                    ; Size in memory image
dq 10h                  ; Alignment
; PHT Entry 13
dd 6474E552h            ; Type: RO-AFTER
dd 4                    ; Flags
dq 2DD0h                ; File offset
dq offset __frame_dummy_init_array_entry ; Virtual address
dq 3DD0h                ; Physical address
dq 230h                 ; Size in file image
dq 230h                 ; Size in memory image
dq 1                    ; Alignment
; ELF Note Entry
dword_350 dd 4          ; Name Size
dd 10h                  ; Desc Size
dd 5                    ; Type: NT_GNU_PROPERTY_TYPE_0
aGnu db 'GNU',0         ; Name
db 2, 80h, 0, 0C0h, 4, 3 dup(0), 1, 7 dup(0) ; Desc
; ELF Note Entry
dword_370 dd 4          ; Name Size
dd 14h                  ; Desc Size
dd 3                    ; Type: NT_GNU_BUILD_ID
aGnu_0 db 'GNU',0       ; Name
db 77h, 0F4h, 65h, 25h, 0B3h, 0BDh, 42h ; Desc
db 9Eh, 0F4h, 0B6h, 97h, 0F5h, 6Dh, 68h
db 2Dh, 13h, 9Ah, 31h, 5Eh, 0B9h
aLib64LdLinuxX8 db '/lib64/ld-linux-x86-64.so.2',0
; ELF GNU Hash Table
elf_gnu_hash_nbuckets dd 2
elf_gnu_hash_symbias dd 11h
elf_gnu_hash_bitmask_nwords dd 1
elf_gnu_hash_shift dd 6
elf_gnu_hash_indexes dq 10010000810000h
elf_gnu_hash_bucket dd 11h, 0
elf_gnu_hash_chain dd 1C8C1D28h, 6DCE65D1h
; ELF Symbol Table
Elf64_Sym <0>
Elf64_Sym <offset aPutchar - offset unk_5A0,\ ; "putchar"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aLibcStartMain - offset unk_5A0,\ ; "__libc_start_main"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aItmDeregistert - offset unk_5A0,\ ; "_ITM_deregisterTMCloneTable"
           20h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aPuts - offset unk_5A0,\ ; "puts"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aFclose - offset unk_5A0,\ ; "fclose"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aSetbuf - offset unk_5A0,\ ; "setbuf"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aPrintf - offset unk_5A0,\ ; "printf"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aFgets - offset unk_5A0,\ ; "fgets"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aStrcmp - offset unk_5A0,\ ; "strcmp"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aGetchar - offset unk_5A0,\ ; "getchar"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aGmonStart - offset unk_5A0,\ ; "__gmon_start__"
           20h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aFgets+1 - offset unk_5A0,\ ; "gets"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aFopen - offset unk_5A0,\ ; "fopen"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aIsoc99Scanf - offset unk_5A0,\ ; "__isoc99_scanf"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aExit - offset unk_5A0,\ ; "exit"
           12h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aItmRegistertmc - offset unk_5A0,\ ; "_ITM_registerTMCloneTable"
           20h, 0, 0, offset dword_0, 0>
Elf64_Sym <offset aStdout - offset unk_5A0,\ ; "stdout"
           11h, 0, 1Ah, \
           offset stdout@GLIBC_2_2_5, 8>
Elf64_Sym <offset aCxaFinalize - offset unk_5A0,\ ; "__cxa_finalize"
           22h, 0, 0, offset dword_0, 0>
; ELF String Table
unk_5A0 db    0
aFgets db 'fgets',0
aPuts db 'puts',0
aExit db 'exit',0
aSetbuf db 'setbuf',0
aPutchar db 'putchar',0
aFopen db 'fopen',0
aGetchar db 'getchar',0
aStdout db 'stdout',0
aLibcStartMain db '__libc_start_main',0
aCxaFinalize db '__cxa_finalize',0
aFclose db 'fclose',0
aPrintf db 'printf',0
aIsoc99Scanf db '__isoc99_scanf',0
aStrcmp db 'strcmp',0
aLibcSo6 db 'libc.so.6',0
aGlibc27 db 'GLIBC_2.7',0
aGlibc234 db 'GLIBC_2.34',0
aGlibc225 db 'GLIBC_2.2.5',0
aItmDeregistert db '_ITM_deregisterTMCloneTable',0
aGmonStart db '__gmon_start__',0
aItmRegistertmc db '_ITM_registerTMCloneTable',0
; ELF GNU Symbol Version Table
dw 0
dw 2                    ; putchar@@GLIBC_2.2.5
dw 3                    ; __libc_start_main@@GLIBC_2.34
dw 1                    ; global symbol: _ITM_deregisterTMCloneTable
dw 2                    ; puts@@GLIBC_2.2.5
dw 2                    ; fclose@@GLIBC_2.2.5
dw 2                    ; setbuf@@GLIBC_2.2.5
dw 2                    ; printf@@GLIBC_2.2.5
dw 2                    ; fgets@@GLIBC_2.2.5
dw 2                    ; strcmp@@GLIBC_2.2.5
dw 2                    ; getchar@@GLIBC_2.2.5
dw 1                    ; global symbol: __gmon_start__
dw 2                    ; gets@@GLIBC_2.2.5
dw 2                    ; fopen@@GLIBC_2.2.5
dw 4                    ; __isoc99_scanf@@GLIBC_2.7
dw 2                    ; exit@@GLIBC_2.2.5
dw 1                    ; global symbol: _ITM_registerTMCloneTable
dw 2                    ; stdout@@GLIBC_2.2.5
dw 2                    ; __cxa_finalize@@GLIBC_2.2.5
; ELF GNU Symbol Version Requirements
Elf64_Verneed <1, 3, \  ; "libc.so.6"
               offset aLibcSo6 - offset unk_5A0,\
               10h, 0>
Elf64_Vernaux <0D696917h, 0, 4, \ ; "GLIBC_2.7"
               offset aGlibc27 - offset unk_5A0,\
               10h>
Elf64_Vernaux <69691B4h, 0, 3, \ ; "GLIBC_2.34"
               offset aGlibc234 - offset unk_5A0,\
               10h>
Elf64_Vernaux <9691A75h, 0, 2, \ ; "GLIBC_2.2.5"
               offset aGlibc225 - offset unk_5A0,\
               0>
; ELF RELA Relocation Table
Elf64_Rela <3DD0h, 8, 11E0h> ; R_X86_64_RELATIVE +11E0h
Elf64_Rela <3DD8h, 8, 11A0h> ; R_X86_64_RELATIVE +11A0h
Elf64_Rela <4068h, 8, 4068h> ; R_X86_64_RELATIVE +4068h
Elf64_Rela <3FC0h, 200000006h, 0> ; R_X86_64_GLOB_DAT __libc_start_main
Elf64_Rela <3FC8h, 300000006h, 0> ; R_X86_64_GLOB_DAT _ITM_deregisterTMCloneTable
Elf64_Rela <3FD0h, 0B00000006h, 0> ; R_X86_64_GLOB_DAT __gmon_start__
Elf64_Rela <3FD8h, 1000000006h, 0> ; R_X86_64_GLOB_DAT _ITM_registerTMCloneTable
Elf64_Rela <3FE0h, 1200000006h, 0> ; R_X86_64_GLOB_DAT __cxa_finalize
Elf64_Rela <4070h, 1100000005h, 0> ; R_X86_64_COPY stdout
; ELF JMPREL Relocation Table
Elf64_Rela <4000h, 100000007h, 0> ; R_X86_64_JUMP_SLOT putchar
Elf64_Rela <4008h, 400000007h, 0> ; R_X86_64_JUMP_SLOT puts
Elf64_Rela <4010h, 500000007h, 0> ; R_X86_64_JUMP_SLOT fclose
Elf64_Rela <4018h, 600000007h, 0> ; R_X86_64_JUMP_SLOT setbuf
Elf64_Rela <4020h, 700000007h, 0> ; R_X86_64_JUMP_SLOT printf
Elf64_Rela <4028h, 800000007h, 0> ; R_X86_64_JUMP_SLOT fgets
Elf64_Rela <4030h, 900000007h, 0> ; R_X86_64_JUMP_SLOT strcmp
Elf64_Rela <4038h, 0A00000007h, 0> ; R_X86_64_JUMP_SLOT getchar
Elf64_Rela <4040h, 0C00000007h, 0> ; R_X86_64_JUMP_SLOT gets
Elf64_Rela <4048h, 0D00000007h, 0> ; R_X86_64_JUMP_SLOT fopen
Elf64_Rela <4050h, 0E00000007h, 0> ; R_X86_64_JUMP_SLOT __isoc99_scanf
Elf64_Rela <4058h, 0F00000007h, 0> ; R_X86_64_JUMP_SLOT exit
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_init segment dword public 'CODE' use64
assume cs:_init
;org 1000h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing


; Alternative name is '_init'

public _init_proc
_init_proc proc near
sub     rsp, 8
mov     rax, cs:__gmon_start___ptr
test    rax, rax
jz      short loc_1012
call    rax ; __gmon_start__

loc_1012:
add     rsp, 8
retn
_init_proc endp

_init ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment mempage public 'CODE' use64
assume cs:LOAD
;org 1017h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 20h
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_plt segment para public 'CODE' use64
assume cs:_plt
;org 1020h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



sub_1020 proc near
; __unwind {
push    cs:qword_3FF0
jmp     cs:qword_3FF8
sub_1020 endp

align 10h
; [00000006 BYTES: COLLAPSED FUNCTION _putchar. PRESS CTRL-NUMPAD+ TO EXPAND]
push    0
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _puts. PRESS CTRL-NUMPAD+ TO EXPAND]
push    1
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _fclose. PRESS CTRL-NUMPAD+ TO EXPAND]
push    2
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _setbuf. PRESS CTRL-NUMPAD+ TO EXPAND]
push    3
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _printf. PRESS CTRL-NUMPAD+ TO EXPAND]
push    4
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _fgets. PRESS CTRL-NUMPAD+ TO EXPAND]
push    5
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _strcmp. PRESS CTRL-NUMPAD+ TO EXPAND]
push    6
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _getchar. PRESS CTRL-NUMPAD+ TO EXPAND]
push    7
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _gets. PRESS CTRL-NUMPAD+ TO EXPAND]
push    8
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _fopen. PRESS CTRL-NUMPAD+ TO EXPAND]
push    9
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION ___isoc99_scanf. PRESS CTRL-NUMPAD+ TO EXPAND]
push    0Ah
jmp     sub_1020
; [00000006 BYTES: COLLAPSED FUNCTION _exit. PRESS CTRL-NUMPAD+ TO EXPAND]
push    0Bh
jmp     sub_1020
; } // starts at 1020
_plt ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_plt_got segment qword public 'CODE' use64
assume cs:_plt_got
;org 10F0h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; [00000006 BYTES: COLLAPSED FUNCTION __cxa_finalize. PRESS CTRL-NUMPAD+ TO EXPAND]
align 8
; } // starts at 10F0
_plt_got ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment mempage public 'CODE' use64
assume cs:LOAD
;org 10F8h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 20h
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_text segment para public 'CODE' use64
assume cs:_text
;org 1100h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing


; Attributes: noreturn fuzzy-sp

public _start
_start proc near
; __unwind {
xor     ebp, ebp
mov     r9, rdx         ; rtld_fini
pop     rsi             ; argc
mov     rdx, rsp        ; ubp_av
and     rsp, 0FFFFFFFFFFFFFFF0h
push    rax
push    rsp             ; stack_end
xor     r8d, r8d        ; fini
xor     ecx, ecx        ; init
lea     rdi, main       ; main
call    cs:__libc_start_main_ptr
hlt
; } // starts at 1100
_start endp

align 10h



deregister_tm_clones proc near
lea     rdi, stdout@GLIBC_2_2_5
lea     rax, stdout@GLIBC_2_2_5
cmp     rax, rdi
jz      short locret_1158
mov     rax, cs:_ITM_deregisterTMCloneTable_ptr
test    rax, rax
jz      short locret_1158
jmp     rax
align 8

locret_1158:
retn
deregister_tm_clones endp

align 20h



register_tm_clones proc near
lea     rdi, stdout@GLIBC_2_2_5
lea     rsi, stdout@GLIBC_2_2_5
sub     rsi, rdi
mov     rax, rsi
shr     rsi, 3Fh
sar     rax, 3
add     rsi, rax
sar     rsi, 1
jz      short locret_1198
mov     rax, cs:_ITM_registerTMCloneTable_ptr
test    rax, rax
jz      short locret_1198
jmp     rax
align 8

locret_1198:
retn
register_tm_clones endp

align 20h



__do_global_dtors_aux proc near
endbr64
cmp     cs:completed_0, 0
jnz     short locret_11D8
push    rbp
cmp     cs:__cxa_finalize_ptr, 0
mov     rbp, rsp
jz      short loc_11C7
mov     rdi, cs:__dso_handle ; void *
call    __cxa_finalize

loc_11C7:
call    deregister_tm_clones
mov     cs:completed_0, 1
pop     rbp
retn
align 8

locret_11D8:
retn
__do_global_dtors_aux endp

align 20h



frame_dummy proc near
endbr64
jmp     register_tm_clones
frame_dummy endp




public pop
pop proc near
; __unwind {
pop     rdi
retn
pop endp ; sp-analysis failed

pop     rsi
retn
pop     rdx
retn
pop     rcx
retn
pop     r8
retn
db 90h
ud2
; } // starts at 11E9


; Attributes: bp-based frame

public secret
secret proc near

var_98= qword ptr -98h
var_90= qword ptr -90h
var_88= qword ptr -88h
var_80= qword ptr -80h
var_78= qword ptr -78h
s= byte ptr -70h
stream= qword ptr -8

; __unwind {
push    rbp
mov     rbp, rsp
sub     rsp, 0A0h
mov     [rbp+var_78], rdi
mov     [rbp+var_80], rsi
mov     [rbp+var_88], rdx
mov     [rbp+var_90], rcx
mov     [rbp+var_98], r8
lea     rax, modes      ; "r"
mov     rsi, rax        ; modes
lea     rax, filename   ; "flag.txt"
mov     rdi, rax        ; filename
call    _fopen
mov     [rbp+stream], rax
cmp     [rbp+stream], 0
jnz     short loc_125C
lea     rax, s          ; "flag.txt not found"
mov     rdi, rax        ; s
call    _puts
mov     edi, 0FFFFFFFFh ; status
call    _exit

loc_125C:
mov     rax, 0DEADBEEFDEADBEEFh
cmp     [rbp+var_78], rax
jnz     loc_12F5
mov     rax, 0C0DEBABEC0DEBABEh
cmp     [rbp+var_80], rax
jnz     short loc_12F5
mov     rax, 4141414141414141h
cmp     [rbp+var_88], rax
jnz     short loc_12F5
mov     rax, 4242424242424242h
cmp     [rbp+var_90], rax
jnz     short loc_12F5
mov     rax, 4343434343434343h
cmp     [rbp+var_98], rax
jnz     short loc_12F5
mov     rdx, [rbp+stream] ; stream
lea     rax, [rbp+s]
mov     esi, 64h ; 'd'  ; n
mov     rdi, rax        ; s
call    _fgets
mov     rax, [rbp+stream]
mov     rdi, rax        ; stream
call    _fclose
lea     rax, [rbp+s]
mov     rsi, rax
lea     rax, format     ; "Wow, how did you get here? Here's the f"...
mov     rdi, rax        ; format
mov     eax, 0
call    _printf

loc_12F5:
nop
leave
retn
; } // starts at 11F7
secret endp



; Attributes: bp-based frame

public questions
questions proc near

s1= byte ptr -60h
var_40= byte ptr -40h

; __unwind {
push    rbp
mov     rbp, rsp
sub     rsp, 60h
lea     rax, aEnterPassword ; "Enter password\n: "
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
lea     rax, [rbp+s1]
mov     rsi, rax
lea     rax, a31s       ; "%31s"
mov     rdi, rax
mov     eax, 0
call    ___isoc99_scanf
lea     rax, [rbp+s1]
lea     rdx, s2         ; "password"
mov     rsi, rdx        ; s2
mov     rdi, rax        ; s1
call    _strcmp
test    eax, eax
jz      short loc_1362
lea     rax, aError     ; "Error"
mov     rdi, rax        ; s
call    _puts
mov     edi, 1          ; status
call    _exit

loc_1362:
lea     rax, aPasswordIsInco ; "Password is incorrect\n: "
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
lea     rax, [rbp+s1]
mov     rsi, rax
lea     rax, a31s       ; "%31s"
mov     rdi, rax
mov     eax, 0
call    ___isoc99_scanf
lea     rax, [rbp+s1]
lea     rdx, aIncorrect ; "incorrect"
mov     rsi, rdx        ; s2
mov     rdi, rax        ; s1
call    _strcmp
test    eax, eax
jz      short loc_13C4
lea     rax, aError     ; "Error"
mov     rdi, rax        ; s
call    _puts
mov     edi, 1          ; status
call    _exit

loc_13C4:
lea     rax, aTryAgain  ; "Try again\n: "
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
lea     rax, [rbp+s1]
mov     rsi, rax
lea     rax, a31s       ; "%31s"
mov     rdi, rax
mov     eax, 0
call    ___isoc99_scanf
lea     rax, [rbp+s1]
lea     rdx, aAgain     ; "again"
mov     rsi, rdx        ; s2
mov     rdi, rax        ; s1
call    _strcmp
test    eax, eax
jz      short loc_1426
lea     rax, aError     ; "Error"
mov     rdi, rax        ; s
call    _puts
mov     edi, 1          ; status
call    _exit

loc_1426:
lea     rax, aPleaseTryAgain ; "Please try again later\n: "
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
lea     rax, [rbp+s1]
mov     rsi, rax
lea     rax, a31        ; " %31[^\n]"
mov     rdi, rax
mov     eax, 0
call    ___isoc99_scanf
lea     rax, [rbp+s1]
lea     rdx, aAgainLater ; "again later"
mov     rsi, rdx        ; s2
mov     rdi, rax        ; s1
call    _strcmp
test    eax, eax
jz      short loc_1488
lea     rax, aError     ; "Error"
mov     rdi, rax        ; s
call    _puts
mov     edi, 1          ; status
call    _exit

loc_1488:
nop

loc_1489:
call    _getchar
cmp     eax, 0Ah
jnz     short loc_1489
lea     rax, aWhatPercentage ; "What percentage do you remember the pas"...
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
lea     rax, [rbp+s1]
mov     rdi, rax
mov     eax, 0
call    _gets
lea     rax, aLikeThis  ; "like this? "
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
lea     rax, [rbp+s1]
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
mov     edi, 0Ah        ; c
call    _putchar
lea     rax, aPleaseTry ; "Please try ......\n: "
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
lea     rax, [rbp+var_40]
mov     rdi, rax
mov     eax, 0
call    _gets
nop
leave
retn
; } // starts at 12F8
questions endp



; Attributes: bp-based frame

; int __fastcall main(int argc, const char **argv, const char **envp)
public main
main proc near
; __unwind {
push    rbp
mov     rbp, rsp
mov     rax, cs:stdout@GLIBC_2_2_5
mov     esi, 0          ; buf
mov     rdi, rax        ; stream
call    _setbuf
mov     eax, 0
call    questions
mov     eax, 0
pop     rbp
retn
; } // starts at 150F
main endp

_text ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_fini segment dword public 'CODE' use64
assume cs:_fini
;org 1538h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing


; Alternative name is '_fini'

public _term_proc
_term_proc proc near
sub     rsp, 8
add     rsp, 8
retn
_term_proc endp

_fini ends


; Segment type: Pure data
; Segment permissions: Read
_rodata segment qword public 'CONST' use64
assume cs:_rodata
;org 2000h
public _IO_stdin_used
_IO_stdin_used db    1
db    0
db    2
db    0
db    0
db    0
db    0
db    0
; const char modes[2]
modes db 'r',0
; const char filename[]
filename db 'flag.txt',0
; const char s[]
s db 'flag.txt not found',0
align 8
; const char format[]
format db 'Wow, how did you get here? Here',27h
db 's the flag:',0Ah
db '%s',0Ah,0
; const char aEnterPassword[]
aEnterPassword db 'Enter password',0Ah
db ': ',0
a31s db '%31s',0
; const char s2[]
s2 db 'password',0
; const char aError[]
aError db 'Error',0
; const char aPasswordIsInco[]
aPasswordIsInco db 'Password is incorrect',0Ah
db ': ',0
; const char aIncorrect[]
aIncorrect db 'incorrect',0
; const char aTryAgain[]
aTryAgain db 'Try again',0Ah
db ': ',0
; const char aAgain[]
aAgain db 'again',0
; const char aPleaseTryAgain[]
aPleaseTryAgain db 'Please try again later',0Ah
db ': ',0
a31 db ' %31[^',0Ah
db ']',0
; const char aAgainLater[]
aAgainLater db 'again later',0
align 8
; const char aWhatPercentage[]
aWhatPercentage db 'What percentage do you remember the'
db ' password?',0Ah
db ': ',0
; const char aLikeThis[]
aLikeThis db 'like this? ',0
; const char aPleaseTry[]
aPleaseTry db 'Please try ......',0Ah
db ': ',0
_rodata ends


; Segment type: Pure data
; Segment permissions: Read
LOAD segment mempage public 'DATA' use64
assume cs:LOAD
;org 213Ah
align 4
LOAD ends


; Segment type: Pure data
; Segment permissions: Read
_eh_frame_hdr segment dword public 'CONST' use64
assume cs:_eh_frame_hdr
;org 213Ch
__GNU_EH_FRAME_HDR db    1
db  1Bh
db    3
db  3Bh ; ;
db  40h ; @
db    0
db    0
db    0
db    7
db    0
db    0
db    0
db 0E4h
db 0EEh
db 0FFh
db 0FFh
db  8Ch
db    0
db    0
db    0
db 0B4h
db 0EFh
db 0FFh
db 0FFh
db 0B4h
db    0
db    0
db    0
db 0C4h
db 0EFh
db 0FFh
db 0FFh
db  5Ch ; \
db    0
db    0
db    0
db 0ADh
db 0F0h
db 0FFh
db 0FFh
db 0CCh
db    0
db    0
db    0
db 0BBh
db 0F0h
db 0FFh
db 0FFh
db 0E0h
db    0
db    0
db    0
db 0BCh
db 0F1h
db 0FFh
db 0FFh
db    0
db    1
db    0
db    0
db 0D3h
db 0F3h
db 0FFh
db 0FFh
db  20h
db    1
db    0
db    0
_eh_frame_hdr ends


; Segment type: Pure data
; Segment permissions: Read
_eh_frame segment qword public 'CONST' use64
assume cs:_eh_frame
;org 2180h
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah ; z
db  52h ; R
db    0
db    1
db  78h ; x
db  10h
db    1
db  1Bh
db  0Ch
db    7
db    8
db  90h
db    1
db    7
db  10h
db  14h
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  60h ; `
db 0EFh
db 0FFh
db 0FFh
db  22h ; "
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah ; z
db  52h ; R
db    0
db    1
db  78h ; x
db  10h
db    1
db  1Bh
db  0Ch
db    7
db    8
db  90h
db    1
db    0
db    0
db  24h ; $
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  50h ; P
db 0EEh
db 0FFh
db 0FFh
db 0D0h
db    0
db    0
db    0
db    0
db  0Eh
db  10h
db  46h ; F
db  0Eh
db  18h
db  4Ah ; J
db  0Fh
db  0Bh
db  77h ; w
db    8
db  80h
db    0
db  3Fh ; ?
db  1Ah
db  3Bh ; ;
db  2Ah ; *
db  33h ; 3
db  24h ; $
db  22h ; "
db    0
db    0
db    0
db    0
db  14h
db    0
db    0
db    0
db  44h ; D
db    0
db    0
db    0
db 0F8h
db 0EEh
db 0FFh
db 0FFh
db    8
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  10h
db    0
db    0
db    0
db  5Ch ; \
db    0
db    0
db    0
db 0D9h
db 0EFh
db 0FFh
db 0FFh
db  0Eh
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  70h ; p
db    0
db    0
db    0
db 0D3h
db 0EFh
db 0FFh
db 0FFh
db    1
db    1
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    2
db 0FCh
db  0Ch
db    7
db    8
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  90h
db    0
db    0
db    0
db 0B4h
db 0F0h
db 0FFh
db 0FFh
db  17h
db    2
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    3
db  12h
db    2
db  0Ch
db    7
db    8
db    0
db  1Ch
db    0
db    0
db    0
db 0B0h
db    0
db    0
db    0
db 0ABh
db 0F2h
db 0FFh
db 0FFh
db  29h ; )
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db  64h ; d
db  0Ch
db    7
db    8
db    0
db    0
db    0
__FRAME_END__ db    0
db    0
db    0
db    0
_eh_frame ends

; ELF Note Entry

; Segment type: Pure data
; Segment permissions: Read
LOAD segment mempage public 'DATA' use64
assume cs:LOAD
;org 2280h
__abi_tag dd 4          ; Name Size
dd 10h                  ; Desc Size
dd 1                    ; Type: NT_GNU_ABI_TAG
aGnu_1 db 'GNU',0       ; Name
dd 0, 3, 2, 0           ; ABI: Linux 3.2.0
LOAD ends

; ELF Initialization Function Table

; Segment type: Pure data
; Segment permissions: Read/Write
_init_array segment qword public 'DATA' use64
assume cs:_init_array
;org 3DD0h
__frame_dummy_init_array_entry dq offset frame_dummy
_init_array ends

; ELF Termination Function Table

; Segment type: Pure data
; Segment permissions: Read/Write
_fini_array segment qword public 'DATA' use64
assume cs:_fini_array
;org 3DD8h
__do_global_dtors_aux_fini_array_entry dq offset __do_global_dtors_aux
_fini_array ends

; ELF Dynamic Information

; Segment type: Pure data
; Segment permissions: Read/Write
LOAD segment mempage public 'DATA' use64
assume cs:LOAD
;org 3DE0h
_DYNAMIC Elf64_Dyn <1, 7Ah> ; DT_NEEDED libc.so.6
Elf64_Dyn <0Ch, 1000h>  ; DT_INIT
Elf64_Dyn <0Dh, 1538h>  ; DT_FINI
Elf64_Dyn <19h, 3DD0h>  ; DT_INIT_ARRAY
Elf64_Dyn <1Bh, 8>      ; DT_INIT_ARRAYSZ
Elf64_Dyn <1Ah, 3DD8h>  ; DT_FINI_ARRAY
Elf64_Dyn <1Ch, 8>      ; DT_FINI_ARRAYSZ
Elf64_Dyn <6FFFFEF5h, 3B0h> ; DT_GNU_HASH
Elf64_Dyn <5, 5A0h>     ; DT_STRTAB
Elf64_Dyn <6, 3D8h>     ; DT_SYMTAB
Elf64_Dyn <0Ah, 0EAh>   ; DT_STRSZ
Elf64_Dyn <0Bh, 18h>    ; DT_SYMENT
Elf64_Dyn <15h, 0>      ; DT_DEBUG
Elf64_Dyn <3, 3FE8h>    ; DT_PLTGOT
Elf64_Dyn <2, 120h>     ; DT_PLTRELSZ
Elf64_Dyn <14h, 7>      ; DT_PLTREL
Elf64_Dyn <17h, 7C8h>   ; DT_JMPREL
Elf64_Dyn <7, 6F0h>     ; DT_RELA
Elf64_Dyn <8, 0D8h>     ; DT_RELASZ
Elf64_Dyn <9, 18h>      ; DT_RELAENT
Elf64_Dyn <6FFFFFFBh, 8000000h> ; DT_FLAGS_1
Elf64_Dyn <6FFFFFFEh, 6B0h> ; DT_VERNEED
Elf64_Dyn <6FFFFFFFh, 1> ; DT_VERNEEDNUM
Elf64_Dyn <6FFFFFF0h, 68Ah> ; DT_VERSYM
Elf64_Dyn <6FFFFFF9h, 3> ; DT_RELACOUNT
Elf64_Dyn <0>           ; DT_NULL
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
LOAD ends


; Segment type: Pure data
; Segment permissions: Read/Write
_got segment qword public 'DATA' use64
assume cs:_got
;org 3FC0h
__libc_start_main_ptr dq offset __libc_start_main
_ITM_deregisterTMCloneTable_ptr dq offset _ITM_deregisterTMCloneTable
__gmon_start___ptr dq offset __gmon_start__
_ITM_registerTMCloneTable_ptr dq offset _ITM_registerTMCloneTable
__cxa_finalize_ptr dq offset __imp___cxa_finalize
_got ends


; Segment type: Pure data
; Segment permissions: Read/Write
_got_plt segment qword public 'DATA' use64
assume cs:_got_plt
;org 3FE8h
_GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC
qword_3FF0 dq 0
qword_3FF8 dq 0
off_4000 dq offset putchar
off_4008 dq offset puts
off_4010 dq offset fclose
off_4018 dq offset setbuf
off_4020 dq offset printf
off_4028 dq offset fgets
off_4030 dq offset strcmp
off_4038 dq offset getchar
off_4040 dq offset gets
off_4048 dq offset fopen
off_4050 dq offset __isoc99_scanf
off_4058 dq offset exit
_got_plt ends


; Segment type: Pure data
; Segment permissions: Read/Write
_data segment qword public 'DATA' use64
assume cs:_data
;org 4060h
public __data_start
__data_start db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
public __dso_handle
; void *_dso_handle
__dso_handle dq offset __dso_handle
_data ends


; Segment type: Uninitialized
; Segment permissions: Read/Write
_bss segment qword public 'BSS' use64
assume cs:_bss
;org 4070h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
public stdout@GLIBC_2_2_5
; FILE *stdout
stdout@GLIBC_2_2_5 dq ? ; Alternative name is '__TMC_END__'
                        ; Alternative name is 'stdout'
                        ; Alternative name is '_edata'
                        ; Alternative name is '__bss_start'
                        ; Copy of shared data
completed_0 db ?
align 20h
_bss ends


; Segment type: Zero-length
_prgend segment byte public '' use64
_end label byte
_prgend ends


; Segment type: Externs
; extern
; int putchar(int c)
extrn putchar:near
; int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end)
extrn __libc_start_main:near
; int puts(const char *s)
extrn puts:near
; int fclose(FILE *stream)
extrn fclose:near
; void setbuf(FILE *stream, char *buf)
extrn setbuf:near
; int printf(const char *format, ...)
extrn printf:near
; char *fgets(char *s, int n, FILE *stream)
extrn fgets:near
; int strcmp(const char *s1, const char *s2)
extrn strcmp:near
; int getchar(void)
extrn getchar:near
extrn gets:near
; FILE *fopen(const char *filename, const char *modes)
extrn fopen:near
extrn __isoc99_scanf:near
; void __noreturn exit(int status)
extrn exit:near
; int __cxa_finalize(void *)
extrn __imp___cxa_finalize:near ; weak
extrn _ITM_deregisterTMCloneTable ; weak
extrn __gmon_start__:near ; weak
extrn _ITM_registerTMCloneTable ; weak


end _start
